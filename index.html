<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>War at Sea Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f0f0f0;
        }
        #container {
            display: flex;
            gap: 10px;
        }
        #canvas-container {
            flex: 2;
        }
        #controls {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #gameCanvas {
            border: 1px solid black;
            background-color: #000;
        }
        button, select, input {
            padding: 5px;
            margin: 2px;
        }
        #responseArea, #bayesOutput {
            width: 100%;
            height: 150px;
            resize: none;
        }
        #turnInfo {
            font-weight: bold;
        }
        #chatSection {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #chatInput {
            width: 100%;
            height: 100px;
            resize: vertical;
            padding: 5px;
            font-size: 14px;
        }
        #chatButton {
            align-self: flex-end;
        }
        #roomSelection {
            margin-bottom: 10px;
        }
        .disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>War at Sea Tool</h1>
    <div id="roomSelection">
        <label for="roomSelect">Select Room: </label>
        <select id="roomSelect" onchange="updateRoom()">
            <option value="none">Select a room</option>
            <option value="blue">Blue Room</option>
            <option value="red">Red Room</option>
        </select>
    </div>
    <div id="container">
        <div id="canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        <div id="controls">
            <div id="unitButtons">
                <button id="plaNavyBtn" onclick="setTool('pla_navy')" disabled>PLA Navy</button>
                <button id="plaPlaneBtn" onclick="setTool('pla_plane')" disabled>PLA Plane</button>
                <button id="twnNavyBtn" onclick="setTool('twn')" disabled>Taiwan Navy</button>
                <button id="twnPlaneBtn" onclick="setTool('twn_plane')" disabled>Taiwan Plane</button>
            </div>
            <div>
                <button onclick="setTool('small_search')">Small Search</button>
                <button onclick="setTool('large_search')">Large Search</button>
                <button onclick="setTool('ruler')">Ruler</button>
                <button onclick="setTool('line')">Line</button>
                <button onclick="undo()">Undo</button>
                <button onclick="setTool('select')">Select Unit</button>
            </div>
            <div>
                <button onclick="interactWithGemini()">Talk to Find Risk</button>
                <textarea id="responseArea" readonly></textarea>
            </div>
            <div>
                <button onclick="toggleSearchAreas()">Display Search Plan</button>
            </div>
            <div>
                <input id="bayesInput" type="text" placeholder="Enter search area number">
                <button onclick="runBayesSearch()">Bayes Search</button>
                <textarea id="bayesOutput" readonly></textarea>
            </div>
            <div>
                <button onclick="setLastKnownPosition()">Set Last Known Position</button>
            </div>
            <div>
                <button onclick="toggleOpponentPosition()">Show Opponent's Position</button>
            </div>
            <div id="chatSection">
                <textarea id="chatInput" placeholder="Free chat with Gemini"></textarea>
                <button id="chatButton" onclick="chatWithGemini()">Free Chat with Gemini</button>
            </div>
            <div id="turnInfo">Turn 1: PLA's turn</div>
            <button onclick="endTurn()">End Turn</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let currentTool = null;
        let blueUnits = []; // Blue 玩家的單位
        let redUnits = [];  // Red 玩家的單位
        let circles = [];
        let lines = [];
        let rulerStart = null;
        let rulerEnd = null;
        let lineStart = null;
        let lineEnd = null;
        let draggingUnit = null;
        let dragStart = null;
        let showSearchAreas = true;
        let showOpponent = false; // 控制是否顯示對方態勢
        let lastKnownPosition = { x: 500, y: 600 };
        let turnCount = 1;
        let currentPlayer = 'PLA';
        let currentRoom = 'none'; // 當前房間
        let searchNum = 0;

        // 定義地圖和搜索區域
        const mapImage = new Image();
        mapImage.src = 'Taiwan.png'; // 替換為你的地圖圖片路徑
        const GRID_ROWS = 4;
        const GRID_COLS = 6;
        const GRID_START_X = 100;
        const GRID_START_Y = 300;
        const GRID_CELL_WIDTH = 50;
        const GRID_CELL_HEIGHT = 50;
        const SEARCH_AREAS = [];
        for (let row = 0; row < GRID_ROWS; row++) {
            for (let col = 0; col < GRID_COLS; col++) {
                const x1 = GRID_START_X + col * GRID_CELL_WIDTH;
                const y1 = GRID_START_Y + row * GRID_CELL_HEIGHT;
                const x2 = x1 + GRID_CELL_WIDTH;
                const y2 = y1 + GRID_CELL_HEIGHT;
                SEARCH_AREAS.push({ x1, y1, x2, y2 });
            }
        }

        // 初始化概率
        let probabilities = initializeProbabilities();

        function initializeProbabilities() {
            const center = GRID_COLS - 1;
            const x = Array.from({ length: GRID_COLS }, (_, i) => i);
            const y = x.map(val => Math.exp(-Math.pow(val - center, 2) / 2) / Math.sqrt(2 * Math.PI));
            let probs = [];
            for (let row = 0; row < GRID_ROWS; row++) {
                probs.push(...y);
            }
            const total = probs.reduce((sum, val) => sum + val, 0);
            return probs.map(val => val / total);
        }

        // 更新房間選擇
        function updateRoom() {
            currentRoom = document.getElementById('roomSelect').value;
            const plaNavyBtn = document.getElementById('plaNavyBtn');
            const plaPlaneBtn = document.getElementById('plaPlaneBtn');
            const twnNavyBtn = document.getElementById('twnNavyBtn');
            const twnPlaneBtn = document.getElementById('twnPlaneBtn');

            if (currentRoom === 'blue') {
                plaNavyBtn.disabled = true;
                plaPlaneBtn.disabled = true;
                twnNavyBtn.disabled = false;
                twnPlaneBtn.disabled = false;
                plaNavyBtn.classList.add('disabled');
                plaPlaneBtn.classList.add('disabled');
                twnNavyBtn.classList.remove('disabled');
                twnPlaneBtn.classList.remove('disabled');
            } else if (currentRoom === 'red') {
                plaNavyBtn.disabled = false;
                plaPlaneBtn.disabled = false;
                twnNavyBtn.disabled = true;
                twnPlaneBtn.disabled = true;
                plaNavyBtn.classList.remove('disabled');
                plaPlaneBtn.classList.remove('disabled');
                twnNavyBtn.classList.add('disabled');
                twnPlaneBtn.classList.add('disabled');
            } else {
                plaNavyBtn.disabled = true;
                plaPlaneBtn.disabled = true;
                twnNavyBtn.disabled = true;
                twnPlaneBtn.disabled = true;
                plaNavyBtn.classList.add('disabled');
                plaPlaneBtn.classList.add('disabled');
                twnNavyBtn.classList.add('disabled');
                twnPlaneBtn.classList.add('disabled');
            }
        }

        // 切換顯示對方態勢
        function toggleOpponentPosition() {
            showOpponent = !showOpponent;
            draw();
        }

        // 繪製地圖和單位
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);

            // 繪製搜索區域
            if (showSearchAreas) {
                SEARCH_AREAS.forEach((area, i) => {
                    const prob = probabilities[i];
                    const colorValue = Math.round(255 * (1 - 2 * prob));
                    ctx.fillStyle = `rgba(${255 * 0.7 + colorValue * 0.3}, ${255 * 0.7 + colorValue * 0.3}, ${255 * 0.7 + 255 * 0.3}, 0.7)`;
                    ctx.strokeStyle = 'black';
                    ctx.fillRect(area.x1, area.y1, area.x2 - area.x1, area.y2 - area.y1);
                    ctx.strokeRect(area.x1, area.y1, area.x2 - area.x1, area.y2 - area.y1);

                    ctx.fillStyle = prob < 0.5 ? 'black' : 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText(`${i + 1} (${prob.toFixed(2)})`, area.x1 + 3, area.y1 + 15);
                });
            }

            // 繪製己方單位
            const myUnits = currentRoom === 'blue' ? blueUnits : redUnits;
            myUnits.forEach(unit => {
                ctx.beginPath();
                ctx.arc(unit.x, unit.y, 5, 0, Math.PI * 2);
                ctx.strokeStyle = unit.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                if (unit === draggingUnit) {
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, 7, 0, Math.PI * 2);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.beginPath();
                    ctx.arc(unit.initialX, unit.initialY, 80, 0, Math.PI * 2);
                    ctx.strokeStyle = 'cyan';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });

            // 繪製對方單位（如果啟用）
            if (showOpponent) {
                const opponentUnits = currentRoom === 'blue' ? redUnits : blueUnits;
                opponentUnits.forEach(unit => {
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, 5, 0, Math.PI * 2);
                    ctx.strokeStyle = unit.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5; // 半透明顯示對方單位
                    ctx.setLineDash([5, 5]); // 虛線
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 1.0; // 恢復透明度
                });
            }

            // 繪製搜索圓形
            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                ctx.strokeStyle = circle.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // 繪製線條
            lines.forEach(line => {
                ctx.beginPath();
                ctx.moveTo(line.startX, line.startY);
                ctx.lineTo(line.endX, line.endY);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // 繪製標尺
            if (rulerStart && rulerEnd) {
                ctx.beginPath();
                ctx.moveTo(rulerStart.x, rulerStart.y);
                ctx.lineTo(rulerEnd.x, rulerEnd.y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                const distance = calculateDistance(rulerStart, rulerEnd);
                const midX = (rulerStart.x + rulerEnd.x) / 2;
                const midY = (rulerStart.y + rulerEnd.y) / 2;
                ctx.fillStyle = 'black';
                ctx.fillText(`${distance.toFixed(2)} ''`, midX, midY);
            }

            // 繪製最後已知位置
            ctx.fillStyle = 'red';
            ctx.font = '16px Arial';
            ctx.fillText('+', lastKnownPosition.x, lastKnownPosition.y);
            ctx.fillText('+ = Last Known Position', lastKnownPosition.x + 20, lastKnownPosition.y);
        }

        function calculateDistance(start, end) {
            return (Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2)) - 5) / 10;
        }

        // 設置工具
        function setTool(tool) {
            if (currentRoom === 'none') {
                alert('Please select a room first!');
                return;
            }
            currentTool = tool;
            rulerStart = null;
            rulerEnd = null;
            lineStart = null;
            lineEnd = null;
        }

        // 撤銷操作
        function undo() {
            if (lines.length > 0) {
                lines.pop();
            } else if (circles.length > 0) {
                circles.pop();
            }
            draw();
        }

        // 切換搜索區域顯示
        function toggleSearchAreas() {
            showSearchAreas = !showSearchAreas;
            draw();
        }

        // 設置最後已知位置
        function setLastKnownPosition() {
            setTool('last_known');
        }

        // 結束回合
        function endTurn() {
            if (currentPlayer === 'PLA') {
                currentPlayer = 'TAIWAN';
            } else {
                currentPlayer = 'PLA';
                turnCount++;
            }
            document.getElementById('turnInfo').textContent = `Turn ${turnCount}: ${currentPlayer}'s turn`;
            draw();
        }

        // 與後端交互
        async function interactWithGemini() {
            const canvasData = canvas.toDataURL('image/png');
            try {
                const response = await fetch('https://us-central1-YOUR_PROJECT_ID.cloudfunctions.net/find_risk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ image: canvasData }),
                });
                const data = await response.json();
                document.getElementById('responseArea').value = data.message || 'No response';
            } catch (error) {
                document.getElementById('responseArea').value = `Error: ${error.message}`;
            }
        }

        // 自由聊天
        async function chatWithGemini() {
            const canvasData = canvas.toDataURL('image/png');
            const userInput = document.getElementById('chatInput').value;
            try {
                const response = await fetch('https://us-central1-YOUR_PROJECT_ID.cloudfunctions.net/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ image: canvasData, message: userInput }),
                });
                const data = await response.json();
                document.getElementById('responseArea').value += `\nYou: ${userInput}\nGemini: ${data.message || 'No response'}\n`;
                document.getElementById('chatInput').value = '';
            } catch (error) {
                document.getElementById('responseArea').value += `\nError: ${error.message}\n`;
            }
        }

        // 貝葉斯搜索（模擬）
        function runBayesSearch() {
            const choice = document.getElementById('bayesInput').value;
            let output = '';
            if (choice === '0') {
                window.location.reload();
            } else if (/^\d+$/.test(choice) && parseInt(choice) >= 1 && parseInt(choice) <= SEARCH_AREAS.length) {
                searchNum++;
                output = `Search ${searchNum} Results: Not Found\n`;
                probabilities = probabilities.map(p => p * 0.9);
                const total = probabilities.reduce((sum, val) => sum + val, 0);
                probabilities = probabilities.map(val => p / total);
                draw();
            } else {
                output = 'INVALID INPUT\n';
            }
            document.getElementById('bayesOutput').value = output;
        }

        // 滑鼠事件處理
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'select') {
                const myUnits = currentRoom === 'blue' ? blueUnits : redUnits;
                myUnits.forEach(unit => {
                    if (Math.pow(x - unit.x, 2) + Math.pow(y - unit.y, 2) <= 25) {
                        draggingUnit = unit;
                        dragStart = { x, y };
                    }
                });
            } else if (currentTool === 'ruler') {
                rulerStart = { x, y };
                rulerEnd = null;
            } else if (currentTool === 'line') {
                lineStart = { x, y };
                lineEnd = null;
            } else if (currentTool === 'last_known') {
                lastKnownPosition = { x, y };
                currentTool = null;
            } else if (currentTool === 'pla_navy' && currentRoom === 'red') {
                redUnits.push({ x, y, initialX: x, initialY: y, color: 'red', type: 'pla_navy' });
            } else if (currentTool === 'pla_plane' && currentRoom === 'red') {
                redUnits.push({ x, y, initialX: x, initialY: y, color: 'rgb(255, 150, 150)', type: 'pla_plane' });
            } else if (currentTool === 'twn' && currentRoom === 'blue') {
                blueUnits.push({ x, y, initialX: x, initialY: y, color: 'blue', type: 'twn' });
            } else if (currentTool === 'twn_plane' && currentRoom === 'blue') {
                blueUnits.push({ x, y, initialX: x, initialY: y, color: 'rgb(150, 150, 255)', type: 'twn_plane' });
            } else if (currentTool === 'small_search') {
                circles.push({ x, y, radius: 35, color: 'yellow' });
            } else if (currentTool === 'large_search') {
                circles.push({ x, y, radius: 50, color: 'yellow' });
            }

            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!draggingUnit && !rulerStart && !lineStart) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (draggingUnit) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;
                let newX = draggingUnit.x + dx;
                let newY = draggingUnit.y + dy;

                const distance = Math.sqrt(Math.pow(newX - draggingUnit.initialX, 2) + Math.pow(newY - draggingUnit.initialY, 2));
                if (distance <= 80) {
                    draggingUnit.x = newX;
                    draggingUnit.y = newY;
                } else {
                    const angle = Math.atan2(newY - draggingUnit.initialY, newX - draggingUnit.initialX);
                    draggingUnit.x = draggingUnit.initialX + 80 * Math.cos(angle);
                    draggingUnit.y = draggingUnit.initialY + 80 * Math.sin(angle);
                }
                dragStart = { x, y };
            } else if (rulerStart) {
                rulerEnd = { x, y };
            } else if (lineStart) {
                lineEnd = { x, y };
            }

            draw();
        });

        canvas.addEventListener('mouseup', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (draggingUnit) {
                draggingUnit = null;
                dragStart = null;
            } else if (rulerStart) {
                rulerEnd = { x, y };
            } else if (lineStart) {
                lineEnd = { x, y };
                lines.push({ startX: lineStart.x, startY: lineStart.y, endX: lineEnd.x, endY: lineEnd.y });
                lineStart = null;
                lineEnd = null;
            }

            draw();
        });

        // 當地圖圖片加載完成後繪製
        mapImage.onload = () => {
            draw();
        };
    </script>
</body>
</html>
