<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>War at Sea Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f0f0f0;
        }
        #header {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        #container {
            display: flex;
            gap: 10px;
        }
        #canvas-container {
            flex: 2;
        }
        #controls {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #gameCanvas {
            border: 1px solid black;
            background-color: #000;
        }
        button, select, input {
            padding: 5px;
            margin: 2px;
        }
        #bayesOutput, #chatOutput {
            width: 100%;
            height: 150px;
            resize: none;
        }
        #turnInfo {
            font-weight: bold;
        }
        #chatSection {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #chatInput {
            width: 100%;
            height: 100px;
            resize: vertical;
            padding: 5px;
            font-size: 14px;
        }
        #chatButton {
            align-self: flex-end;
        }
        #roomSelection {
            margin-right: 10px;
        }
        .disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #roomStatus {
            margin-top: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>War at Sea Tool</h1>
    <div id="header">
        <div id="roomSelection">
            <label for="roomSelect">Select Room: </label>
            <select id="roomSelect" onchange="selectRoom()">
                <option value="none">Select a room</option>
                <option value="blue">Blue Room</option>
                <option value="red">Red Room</option>
            </select>
        </div>
        <div id="unitButtons">
            <button id="plaNavyBtn" onclick="setTool('pla_navy')" disabled>PLA Navy</button>
            <button id="plaPlaneBtn" onclick="setTool('pla_plane')" disabled>PLA Plane</button>
            <button id="twnNavyBtn" onclick="setTool('twn')" disabled>Taiwan Navy</button>
            <button id="twnPlaneBtn" onclick="setTool('twn_plane')" disabled>Taiwan Plane</button>
        </div>
        <button onclick="setTool('small_search')">Small Search</button>
        <button onclick="setTool('large_search')">Large Search</button>
        <button onclick="setTool('ruler')">Ruler</button>
        <button onclick="setTool('line')">Line</button>
        <button onclick="undo()">Undo</button>
        <button onclick="setTool('select')">Select Unit</button>
        <button onclick="setTool('delete')">Delete Unit</button>
    </div>
    <div id="roomStatus">
        <p>Blue Player: <span id="blueIp">Not joined</span></p>
        <p>Red Player: <span id="redIp">Not joined</span></p>
    </div>
    <div id="container">
        <div id="canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        <div id="controls">
            <div>
                <button onclick="toggleSearchAreas()">Display Search Plan</button>
            </div>
            <div>
                <input id="bayesInput" type="text" placeholder="Enter search area number">
                <button onclick="runBayesSearch()">Bayes Search</button>
                <textarea id="bayesOutput" readonly></textarea>
            </div>
            <div>
                <button onclick="setLastKnownPosition()">Set Last Known Position</button>
            </div>
            <div>
                <button onclick="toggleOpponentPosition()">Show Opponent's Position</button>
            </div>
            <div id="chatSection">
                <textarea id="chatInput" placeholder="Free chat with Gemini"></textarea>
                <button id="chatButton" onclick="chatWithGemini()">Free Chat with Gemini</button>
                <textarea id="chatOutput" readonly></textarea>
            </div>
            <div id="turnInfo">Turn 1: PLA's turn</div>
            <button onclick="endTurn()">End Turn</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let currentTool = null;
        let blueUnits = [];
        let redUnits = [];
        let circles = [];
        let lines = [];
        let rulerStart = null;
        let rulerEnd = null;
        let lineStart = null;
        let lineEnd = null;
        let draggingUnit = null;
        let dragStart = null;
        let showSearchAreas = true;
        let showOpponent = false;
        let lastKnownPosition = { x: 500, y: 600 };
        let turnCount = 1;
        let currentPlayer = 'PLA';
        let currentRoom = 'none';
        let searchNum = 0;

        const BASE_URL = 'https://wargame-1087471739366.us-central1.run.app';

        const mapImage = new Image();
        mapImage.src = 'https://storage.cloud.google.com/waratsea/Taiwan.png';
        mapImage.onerror = () => {
            console.error('Failed to load map image at: ' + mapImage.src);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Failed to load map image.', 50, 50);
        };
        const GRID_ROWS = 4;
        const GRID_COLS = 6;
        const GRID_START_X = 100;
        const GRID_START_Y = 300;
        const GRID_CELL_WIDTH = 50;
        const GRID_CELL_HEIGHT = 50;
        const SEARCH_AREAS = [];
        for (let row = 0; row < GRID_ROWS; row++) {
            for (let col = 0; col < GRID_COLS; col++) {
                const x1 = GRID_START_X + col * GRID_CELL_WIDTH;
                const y1 = GRID_START_Y + row * GRID_CELL_HEIGHT;
                const x2 = x1 + GRID_CELL_WIDTH;
                const y2 = y1 + GRID_CELL_HEIGHT;
                SEARCH_AREAS.push({ x1, y1, x2, y2 });
            }
        }

        let probabilities = initializeProbabilities();

        function initializeProbabilities() {
            const center = GRID_COLS - 1;
            const x = Array.from({ length: GRID_COLS }, (_, i) => i);
            const y = x.map(val => Math.exp(-Math.pow(val - center, 2) / 2) / Math.sqrt(2 * Math.PI));
            let probs = [];
            for (let row = 0; row < GRID_ROWS; row++) {
                probs.push(...y);
            }
            const total = probs.reduce((sum, val) => sum + val, 0);
            return probs.map(val => val / total);
        }

        async function selectRoom() {
            const room = document.getElementById('roomSelect').value;
            if (room === 'none') {
                currentRoom = 'none';
                updateRoom();
                return;
            }

            try {
                const response = await fetch(`${BASE_URL}/select_room`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ room }),
                });
                const data = await response.json();
                if (data.error) {
                    alert(data.error);
                    document.getElementById('roomSelect').value = 'none';
                    currentRoom = 'none';
                } else {
                    currentRoom = room;
                    updateRoom();
                    updateRoomStatus();
                }
            } catch (error) {
                alert('Error selecting room: ' + error.message);
                document.getElementById('roomSelect').value = 'none';
                currentRoom = 'none';
            }
        }

        function updateRoom() {
            const plaNavyBtn = document.getElementById('plaNavyBtn');
            const plaPlaneBtn = document.getElementById('plaPlaneBtn');
            const twnNavyBtn = document.getElementById('twnNavyBtn');
            const twnPlaneBtn = document.getElementById('twnPlaneBtn');

            if (currentRoom === 'blue') {
                plaNavyBtn.disabled = true;
                plaPlaneBtn.disabled = true;
                twnNavyBtn.disabled = false;
                twnPlaneBtn.disabled = false;
                plaNavyBtn.classList.add('disabled');
                plaPlaneBtn.classList.add('disabled');
                twnNavyBtn.classList.remove('disabled');
                twnPlaneBtn.classList.remove('disabled');
            } else if (currentRoom === 'red') {
                plaNavyBtn.disabled = false;
                plaPlaneBtn.disabled = false;
                twnNavyBtn.disabled = true;
                twnPlaneBtn.disabled = true;
                plaNavyBtn.classList.remove('disabled');
                plaPlaneBtn.classList.remove('disabled');
                twnNavyBtn.classList.add('disabled');
                twnPlaneBtn.classList.add('disabled');
            } else {
                plaNavyBtn.disabled = true;
                plaPlaneBtn.disabled = true;
                twnNavyBtn.disabled = true;
                twnPlaneBtn.disabled = true;
                plaNavyBtn.classList.add('disabled');
                plaPlaneBtn.classList.add('disabled');
                twnNavyBtn.classList.add('disabled');
                twnPlaneBtn.classList.add('disabled');
            }
        }

        async function updateRoomStatus() {
            try {
                const response = await fetch(`${BASE_URL}/get_room_state`);
                const data = await response.json();
                document.getElementById('blueIp').textContent = data.room_state.blue_ip || 'Not joined';
                document.getElementById('redIp').textContent = data.room_state.red_ip || 'Not joined';
            } catch (error) {
                console.error('Error updating room status:', error);
            }
        }

        async function syncUnits() {
            try {
                const response = await fetch(`${BASE_URL}/get_units`);
                const data = await response.json();
                blueUnits = data.blueUnits || [];
                redUnits = data.redUnits || [];
                draw();
            } catch (error) {
                console.error('Error syncing units:', error);
            }
        }

        async function saveUnits() {
            if (currentRoom === 'none') return;
            const units = currentRoom === 'blue' ? blueUnits : redUnits;
            try {
                await fetch(`${BASE_URL}/save_units`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ room: currentRoom, units }),
                });
            } catch (error) {
                console.error('Error saving units:', error);
            }
        }

        setInterval(syncUnits, 5000);
        setInterval(updateRoomStatus, 5000);

        function toggleOpponentPosition() {
            showOpponent = !showOpponent;
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);

            if (showSearchAreas) {
                SEARCH_AREAS.forEach((area, i) => {
                    const prob = probabilities[i];
                    const colorValue = Math.round(255 * (1 - 2 * prob));
                    ctx.fillStyle = `rgba(${255 * 0.7 + colorValue * 0.3}, ${255 * 0.7 + colorValue * 0.3}, ${255 * 0.7 + 255 * 0.3}, 0.7)`;
                    ctx.strokeStyle = 'black';
                    ctx.fillRect(area.x1, area.y1, area.x2 - area.x1, area.y2 - area.y1);
                    ctx.strokeRect(area.x1, area.y1, area.x2 - area.x1, area.y2 - area.y1);

                    ctx.fillStyle = prob < 0.5 ? 'black' : 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText(`${i + 1} (${prob.toFixed(2)})`, area.x1 + 3, area.y1 + 15);
                });
            }

            const myUnits = currentRoom === 'blue' ? blueUnits : redUnits;
            myUnits.forEach(unit => {
                ctx.beginPath();
                ctx.arc(unit.x, unit.y, 5, 0, Math.PI * 2);
                ctx.strokeStyle = unit.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                if (unit === draggingUnit) {
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, 7, 0, Math.PI * 2);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.beginPath();
                    ctx.arc(unit.initialX, unit.initialY, 80, 0, Math.PI * 2);
                    ctx.strokeStyle = 'cyan';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });

            if (showOpponent) {
                const opponentUnits = currentRoom === 'blue' ? redUnits : blueUnits;
                opponentUnits.forEach(unit => {
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, 5, 0, Math.PI * 2);
                    ctx.strokeStyle = unit.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.globalAlpha = 1.0;
                });
            }

            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                ctx.strokeStyle = circle.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            lines.forEach(line => {
                ctx.beginPath();
                ctx.moveTo(line.startX, line.startY);
                ctx.lineTo(line.endX, line.endY);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            if (rulerStart && rulerEnd) {
                ctx.beginPath();
                ctx.moveTo(rulerStart.x, rulerStart.y);
                ctx.lineTo(rulerEnd.x, rulerEnd.y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                const distance = calculateDistance(rulerStart, rulerEnd);
                const midX = (rulerStart.x + rulerEnd.x) / 2;
                const midY = (rulerStart.y + rulerEnd.y) / 2;
                ctx.fillStyle = 'black';
                ctx.fillText(`${distance.toFixed(2)} ''`, midX, midY);
            }

            ctx.fillStyle = 'red';
            ctx.font = '16px Arial';
            ctx.fillText('+', lastKnownPosition.x, lastKnownPosition.y);
            ctx.fillText('+ = Last Known Position', lastKnownPosition.x + 20, lastKnownPosition.y);
        }

        function calculateDistance(start, end) {
            return (Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2)) - 5) / 10;
        }

        function setTool(tool) {
            if (currentRoom === 'none' && tool !== 'delete' && tool !== 'select') {
                alert('Please select a room first!');
                return;
            }
            currentTool = tool;
            rulerStart = null;
            rulerEnd = null;
            lineStart = null;
            lineEnd = null;
        }

        function undo() {
            if (lines.length > 0) {
                lines.pop();
            } else if (circles.length > 0) {
                circles.pop();
            }
            draw();
            saveUnits();
        }

        function toggleSearchAreas() {
            showSearchAreas = !showSearchAreas;
            draw();
        }

        function setLastKnownPosition() {
            setTool('last_known');
        }

        function endTurn() {
            if (currentPlayer === 'PLA') {
                currentPlayer = 'TAIWAN';
            } else {
                currentPlayer = 'PLA';
                turnCount++;
            }
            document.getElementById('turnInfo').textContent = `Turn ${turnCount}: ${currentPlayer}'s turn`;
            draw();
        }

        async function chatWithGemini() {
            const canvasData = canvas.toDataURL('image/png');
            const userInput = document.getElementById('chatInput').value;
            try {
                console.log('Sending request to /chat with input:', userInput);
                const response = await fetch(`${BASE_URL}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ image: canvasData, message: userInput }),
                });
                const data = await response.json();
                console.log('Response from /chat:', data);
                document.getElementById('chatOutput').value += `\nYou: ${userInput}\nGemini: ${data.message || 'No response'}\n`;
                document.getElementById('chatInput').value = '';
            } catch (error) {
                console.error('Error in chatWithGemini:', error);
                document.getElementById('chatOutput').value += `\nError: ${error.message}\n`;
            }
        }

        function runBayesSearch() {
            const choice = document.getElementById('bayesInput').value;
            let output = '';
            if (choice === '0') {
                window.location.reload();
            } else if (/^\d+$/.test(choice) && parseInt(choice) >= 1 && parseInt(choice) <= SEARCH_AREAS.length) {
                searchNum++;
                output = `Search ${searchNum} Results: Not Found\n`;
                probabilities = probabilities.map(p => p * 0.9);
                const total = probabilities.reduce((sum, val) => sum + val, 0);
                probabilities = probabilities.map(val => p / total);
                draw();
            } else {
                output = 'INVALID INPUT\n';
            }
            document.getElementById('bayesOutput').value = output;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'select') {
                const myUnits = currentRoom === 'blue' ? blueUnits : redUnits;
                myUnits.forEach(unit => {
                    if (Math.pow(x - unit.x, 2) + Math.pow(y - unit.y, 2) <= 25) {
                        draggingUnit = unit;
                        dragStart = { x, y };
                    }
                });
            } else if (currentTool === 'delete') {
                const myUnits = currentRoom === 'blue' ? blueUnits : redUnits;
                const unitIndex = myUnits.findIndex(unit => Math.pow(x - unit.x, 2) + Math.pow(y - unit.y, 2) <= 25);
                if (unitIndex !== -1) {
                    myUnits.splice(unitIndex, 1);
                    currentTool = null;
                    saveUnits();
                }
            } else if (currentTool === 'ruler') {
                rulerStart = { x, y };
                rulerEnd = null;
            } else if (currentTool === 'line') {
                lineStart = { x, y };
                lineEnd = null;
            } else if (currentTool === 'last_known') {
                lastKnownPosition = { x, y };
                currentTool = null;
            } else if (currentTool === 'pla_navy' && currentRoom === 'red') {
                redUnits.push({ x, y, initialX: x, initialY: y, color: 'red', type: 'pla_navy' });
                saveUnits();
            } else if (currentTool === 'pla_plane' && currentRoom === 'red') {
                redUnits.push({ x, y, initialX: x, initialY: y, color: 'rgb(255, 150, 150)', type: 'pla_plane' });
                saveUnits();
            } else if (currentTool === 'twn' && currentRoom === 'blue') {
                blueUnits.push({ x, y, initialX: x, initialY: y, color: 'blue', type: 'twn' });
                saveUnits();
            } else if (currentTool === 'twn_plane' && currentRoom === 'blue') {
                blueUnits.push({ x, y, initialX: x, initialY: y, color: 'rgb(150, 150, 255)', type: 'twn_plane' });
                saveUnits();
            } else if (currentTool === 'small_search') {
                circles.push({ x, y, radius: 35, color: 'yellow' });
            } else if (currentTool === 'large_search') {
                circles.push({ x, y, radius: 50, color: 'yellow' });
            }

            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!draggingUnit && !rulerStart && !lineStart) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (draggingUnit) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;
                let newX = draggingUnit.x + dx;
                let newY = draggingUnit.y + dy;

                const distance = Math.sqrt(Math.pow(newX - draggingUnit.initialX, 2) + Math.pow(newY - draggingUnit.initialY, 2));
                if (distance <= 80) {
                    draggingUnit.x = newX;
                    draggingUnit.y = newY;
                } else {
                    const angle = Math.atan2(newY - draggingUnit.initialY, newX - draggingUnit.initialX);
                    draggingUnit.x = draggingUnit.initialX + 80 * Math.cos(angle);
                    draggingUnit.y = draggingUnit.initialY + 80 * Math.sin(angle);
                }
                dragStart = { x, y };
            } else if (rulerStart) {
                rulerEnd = { x, y };
            } else if (lineStart) {
                lineEnd = { x, y };
            }

            draw();
        });

        canvas.addEventListener('mouseup', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (draggingUnit) {
                draggingUnit = null;
                dragStart = null;
                saveUnits();
            } else if (rulerStart) {
                rulerEnd = { x, y };
            } else if (lineStart) {
                lineEnd = { x, y };
                lines.push({ startX: lineStart.x, startY: lineStart.y, endX: lineEnd.x, endY: lineEnd.y });
                lineStart = null;
                lineEnd = null;
            }

            draw();
        });

        mapImage.onload = () => {
            console.log('Map image loaded successfully');
            draw();
            syncUnits();
            updateRoomStatus();
        };
    </script>
</body>
</html>
